<html>
<head>
<script src = "js/ammo.js"></script>
<script src = "js/three.min.js"></script>
</head>
<body>

<h1>Basic Three.js + Ammo Combination</h1>

<script> 
	/****STEP 1: Initialize rendering engine**///

	var scene = new THREE.Scene(); 
	
	//var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
	var width = 640, height = 480;
	var camera = new THREE.PerspectiveCamera( 75, width/height, 0.1, 1000 );
	var renderer = new THREE.WebGLRenderer(); 
	renderer.setSize( width, height ); 
	document.body.appendChild( renderer.domElement ); 

	//Add some lighting
	var light = new THREE.AmbientLight( 0x404040 ); // soft white light
	scene.add( light );
	// directional lighting
	var directionalLight = new THREE.DirectionalLight(0xffffff);
	directionalLight.position.set(1, 1, 1).normalize();
	scene.add(directionalLight);	

	/****STEP 2: Initialize physics engine**/
	 var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration(); // every single |new| currently leaks...
	var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
	var overlappingPairCache = new Ammo.btDbvtBroadphase();
	var solver = new Ammo.btSequentialImpulseConstraintSolver();
	var dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
	dynamicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));

	//****STEP 3: Define world geometry***//
	var material = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
	var mass = 1;
	var colShape = new Ammo.btSphereShape(0.1);
	var radius = 0.5;
	var smoothness = 32;
	var constructSphere = function(radius,mass,x,y,z,v_x,v_y,v_z,smoothness,material,colShape)
	{
	        var sphere = new THREE.Mesh(new THREE.SphereGeometry( radius, smoothness,smoothness ), material );
	        var startTransform = new Ammo.btTransform();
	        startTransform.setIdentity();
	        var isDynamic = (mass != 0);
	        var localInertia = new Ammo.btVector3(v_x,v_y,v_z);
	        if (isDynamic)
	            colShape.calculateLocalInertia(mass,localInertia);
	        startTransform.setOrigin(new Ammo.btVector3(x,y,z));
	        var myMotionState = new Ammo.btDefaultMotionState(startTransform);
	        var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);
	        var sphereBody = new Ammo.btRigidBody(rbInfo);
	        sphereBody.setRestitution(0.9); 
	        this.mesh = sphere;
	        this.body = sphereBody;
	        this.radius = radius;
	        this.x = x;
	        this.y = y;
	        this.z = z;
	};  
	var addShape = function(shape,dynamicsWorld,scene)
	{
	        dynamicsWorld.addRigidBody(shape.body);
	        scene.add(shape.mesh);
    	};
    	var moveSphere = function(shape,trans)
    	{
	    shape.body.getMotionState().getWorldTransform(trans);
	        shape.mesh.position.x = trans.getOrigin().x() + shape.radius/2;
	        shape.mesh.position.y = trans.getOrigin().y() + shape.radius/2;
	        shape.mesh.position.z = trans.getOrigin().z() + shape.radius/2;
	        shape.mesh.updateMatrix();
    	};
	//var sphere1 = new constructSphere(radius,mass, 1,5,2.5, 0,0,0, smoothness,material,colShape);
    	//addShape(sphere1, dynamicsWorld, scene);

    	var shapes = [];
	for (var i = 0; i < 100; i++){
        	shapes.push(new constructSphere(radius,mass, Math.random()*50-25,Math.random()*50-25,Math.random()*50-25, 0,0,0, smoothness,material,colShape));
    	}
/*
	//Rendering part of sphere
	var geometry = new THREE.SphereGeometry( 0.1, 32, 32 ); 
	var material = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
	var sphere = new THREE.Mesh( geometry, material );
	//Physics part of sphere
	//NOTE: You can use the same collision shape for different spheres that are
	//the same size
	var colShape = new Ammo.btSphereShape(0.1);
	var startTransform = new Ammo.btTransform();
	startTransform.setIdentity();
	var mass = 1;
	var isDynamic = (mass != 0);
	var localInertia = new Ammo.btVector3(0, 0, 0);
	if (isDynamic)
		colShape.calculateLocalInertia(mass,localInertia);
	startTransform.setOrigin(new Ammo.btVector3(2, 5, 2.5));
	var myMotionState = new Ammo.btDefaultMotionState(startTransform);
	var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);
	var sphereBody = new Ammo.btRigidBody(rbInfo);
	sphereBody.setRestitution(0.9) //Make it bouncy!
	dynamicsWorld.addRigidBody(sphereBody);
*/	
	//Rendering part of ground
	var gmaterial = new THREE.MeshPhongMaterial( { color: 0x00ff00, shininess: 30 } );
	var ggeometry = new THREE.BoxGeometry(50, 50, 50);	
	var ground = new THREE.Mesh( ggeometry, gmaterial );
	//Physics part of the ground
	var groundShape = new Ammo.btBoxShape(new Ammo.btVector3(50, 50, 50));
	var groundTransform = new Ammo.btTransform();
	groundTransform.setIdentity();
	groundTransform.setOrigin(new Ammo.btVector3(-25, -56, 0));	 
	mass = 0;
	isDynamic = mass !== 0;
	var localInertiaGround = new Ammo.btVector3(0, 0, 0);
	var myMotionState = new Ammo.btDefaultMotionState(groundTransform);
	var rbInfoGround = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, groundShape, localInertiaGround);
	var groundBody = new Ammo.btRigidBody(rbInfoGround);
	groundBody.setRestitution(0.9) //Make it bouncy!
	dynamicsWorld.addRigidBody(groundBody);	
	
	//Rendering part of falling box
	var bfmaterial = new THREE.MeshPhongMaterial( { color: 0x0000ff } );
	var bfgeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);	
	var box = new THREE.Mesh( bfgeometry, bfmaterial );
	//Physics part of the falling box
	var boxShape = new Ammo.btBoxShape(new Ammo.btVector3(0.5, 0.5, 0.5));
	var boxTransform = new Ammo.btTransform();
	boxTransform.setIdentity();
	boxTransform.setOrigin(new Ammo.btVector3(0, 4, 0));	 
	mass = 1;
	boxShape.calculateLocalInertia(mass,localInertia);
	var localInertiaBox = new Ammo.btVector3(1, 1, 1);
	var boxMotionState = new Ammo.btDefaultMotionState(boxTransform);
	var rbInfoBox = new Ammo.btRigidBodyConstructionInfo(mass, boxMotionState, boxShape, localInertiaBox);
	var boxBody = new Ammo.btRigidBody(rbInfoBox);
	boxBody.setRestitution(0.9) //Make it bouncy!
	dynamicsWorld.addRigidBody(boxBody);		
	
	
	var trans = new Ammo.btTransform();
	
	//scene.add( sphere );
	scene.add( ground );
	//scene.add( box ); //Uncomment to put in box
	
	camera.position.z = 15;
	camera.position.x = 5;
	
	var render = function () {
		dynamicsWorld.stepSimulation(1/60, 10);
		groundBody.getMotionState().getWorldTransform(trans);
		ground.position.x = trans.getOrigin().x() + 25;//TODO: Box dimension/2 (an actual variable not the "magic number" 25)
		ground.position.y = trans.getOrigin().y() + 25;
		ground.position.z = trans.getOrigin().z() + 25;
		ground.updateMatrix();
	/*	
		sphereBody.getMotionState().getWorldTransform(trans);
		sphere.position.x = trans.getOrigin().x() + 0.05;
		sphere.position.y = trans.getOrigin().y() + 0.05;
		sphere.position.z = trans.getOrigin().z() + 0.05;
		sphere.updateMatrix();
	*/
		shapes.forEach(function(shape){moveSphere(shape,trans);});
	
		boxBody.getMotionState().getWorldTransform(trans);
		//**This is how you do rotations
		var q = trans.getRotation()
		box.quaternion = THREE.Quaternion(q.x(), q.y(), q.z(), q.w())		
		box.position.x = trans.getOrigin().x() + 0.25;//TODO: Box dimension/2 (an actual variable not the "magic number" 25)
		box.position.y = trans.getOrigin().y() + 0.25;
		box.position.z = trans.getOrigin().z() + 0.25;	
		box.updateMatrix();
		
		requestAnimationFrame( render ); 
		renderer.render(scene, camera);
	}; 
	render();

	//TODO: De-allocate physics things at the appropriate time
	 /* Ammo.destroy(collisionConfiguration);
	  Ammo.destroy(dispatcher);
	  Ammo.destroy(overlappingPairCache);
	  Ammo.destroy(solver);*/

	</script>



</body>
</html>
